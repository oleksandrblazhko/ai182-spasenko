### Тестування схеми керування сеансами
|ID|
|----|
|WSTG-SESS-01|

## Резюме
Одним із основних компонентів будь-якої веб-програми є механізм, за допомогою якого вона контролює та підтримує стан користувача, який з нею взаємодіє. Щоб уникнути безперервної автентифікації для кожної сторінки веб-сайту чи служби, веб-програми реалізують різні механізми для зберігання та перевірки облікових даних протягом заздалегідь визначеного періоду часу. Ці механізми відомі як керування сеансами.

У цьому тесті тестувальник хоче перевірити, чи файли cookie та інші маркери сеансу створюються безпечним і непередбачуваним способом. Зловмисник, здатний передбачити та підробити слабкі файли cookie, може легко захопити сеанси законних користувачів.

Файли cookie використовуються для здійснення керування сеансом і детально описані в RFC 2965. У двох словах, коли користувач отримує доступ до програми, якій потрібно відстежувати дії та ідентифікаційні дані цього користувача за кількома запитами, файл cookie (або файли cookie) генерується сервером і надсилається клієнту. Потім клієнт надсилатиме файл cookie назад на сервер у всіх наступних підключеннях, доки термін дії файлу cookie не закінчиться або не буде знищено. Дані, що зберігаються в файлі cookie, можуть надавати серверу широкий спектр інформації про те, хто такий користувач, які дії він виконував на даний момент, які його переваги тощо, таким чином забезпечуючи стан протоколу без стану, такого як HTTP.

Типовим прикладом є кошик для покупок в Інтернеті. Протягом сеансу користувача програма повинна відстежувати його особу, його профіль, продукти, які він вибрав для покупки, кількість, індивідуальні ціни, знижки тощо. Файли cookie є ефективним способом зберігання та передачі цього інформацію вперед і назад (інші методи – параметри URL-адреси та приховані поля).

Через важливість даних, які вони зберігають, файли cookie є життєво важливими для загальної безпеки програми. Можливість підробити файли cookie може призвести до викрадення сеансів законних користувачів, отримання вищих привілеїв під час активного сеансу та загалом несанкціонованого впливу на роботу програми.

У цьому тесті тестувальник повинен перевірити, чи можуть файли cookie, видані клієнтам, протистояти широкому спектру атак, спрямованих на втручання в сеанси законних користувачів і в саму програму. Загальна мета полягає в тому, щоб мати можливість підробити файл cookie, який програма вважатиме дійсним і який забезпечить певний вид неавторизованого доступу (викрадення сеансу, підвищення привілеїв тощо).

Зазвичай основні етапи шаблону атаки такі:

збір печива: збір достатньої кількості зразків печива;
реверс-інжиніринг cookie: аналіз алгоритму генерації cookie;
маніпуляції файлами cookie: підробка дійсного файлу cookie для здійснення атаки. Цей останній крок може вимагати великої кількості спроб, залежно від того, як створено файл cookie (атака перебору файлів cookie).
Інший шаблон атаки полягає в переповненні файлу cookie. Строго кажучи, ця атака має іншу природу, оскільки тут тестери не намагаються відтворити ідеально дійсний файл cookie. Натомість мета полягає в тому, щоб переповнити область пам’яті, тим самим перешкоджаючи правильній поведінці програми та, можливо, вводячи (і віддалено запускаючи) шкідливий код.

### Цілі тесту
Збирайте маркери сеансу для того самого користувача та для різних користувачів, де це можливо.
Проаналізуйте та переконайтеся, що достатньо випадковості, щоб зупинити атаки підробки сеансу.
Змінювати файли cookie, які не підписані та містять інформацію, якою можна маніпулювати.
Як тестувати
Тестування чорної скриньки та приклади
Усю взаємодію між клієнтом і програмою слід перевіряти принаймні за такими критеріями:

Чи всі директиви Set-Cookie позначені як безпечні?
Чи виконуються будь-які операції з файлами cookie через незашифрований транспорт?
Чи можна використовувати Cookie через незашифрований транспорт?
Якщо так, то як програма підтримує безпеку?
Чи є файли cookie постійними?
Який час дії Expires використовується для постійних файлів cookie та чи це розумно?
Чи файли cookie, які, як очікується, будуть тимчасовими, налаштовані як такі?
Які параметри HTTP/1.1 Cache-Control використовуються для захисту файлів cookie?
Які параметри HTTP/1.0 Cache-Control використовуються для захисту файлів cookie?

### Колекція файлів cookie
Першим кроком, необхідним для маніпулювання файлами cookie, є розуміння того, як програма створює файли cookie та керує ними. Для цього завдання тестувальники повинні спробувати відповісти на такі запитання:

Скільки файлів cookie використовує програма?

Переглядайте програму. Зверніть увагу, коли створюються файли cookie. Складіть список отриманих файлів cookie, сторінку, яка їх встановлює (з директивою set-cookie), домен, для якого вони дійсні, їх значення та характеристики.

Які частини програми створюють або змінюють файли cookie?

Переглядаючи програму, знайдіть, які файли cookie залишаються постійними, а які змінюються. Які події змінюють файл cookie?

Яким частинам програми потрібен цей файл cookie для доступу та використання?

Переглядаючи програму, знайдіть, які файли cookie залишаються постійними, а які змінюються. Які події змінюють файл cookie?

Яким частинам програми потрібен цей файл cookie для доступу та використання?

Дізнайтеся, які частини програми потребують файлів cookie. Перейдіть на сторінку, а потім повторіть спробу без файлу cookie або зі зміненим його значенням. Спробуйте визначити, які файли cookie де використовуються.

Електронна таблиця, що відображає кожен файл cookie з відповідними частинами програми та пов’язаною інформацією, може бути цінним результатом цього етапу.

### Аналіз сесії
Слід перевірити самі маркери сеансу (Cookie, SessionID або Hidden Field), щоб переконатися в їх якості з точки зору безпеки. Їх слід перевіряти за такими критеріями, як їх випадковість, унікальність, стійкість до статистичного та криптографічного аналізу та витоку інформації.

### Структура маркера та витік інформації
Перший етап полягає в дослідженні структури та вмісту ідентифікатора сеансу, наданого програмою. Поширеною помилкою є включення конкретних даних до маркера замість видачі загального значення та посилання на реальні дані на стороні сервера.

Якщо ідентифікатор сеансу є відкритим текстом, структура та відповідні дані можуть бути одразу очевидними, наприклад 192.168.100.1:owaspuser:password:15:58.

Якщо частина або весь токен здається закодованим або хешованим, його слід порівняти з різними методами, щоб перевірити очевидну обфускацію. Наприклад, рядок 192.168.100.1:owaspuser:password:15:58 представлено в Hex, Base64 і як хеш MD5:

Шістнадцятковий: 3139322E3136382E3130302E313A6F77617370757365723A70617373776F72643A31353A3538
Base64: MTkyLjE2OC4xMDAuMTpvd2FzcHVzZXI6cGFzc3dvcmQ6MTU6NTg=
MD5: 01c2fc4f0a817afd8366689bd29dd40a
Визначивши тип обфускації, можна повернутися до вихідних даних. Однак у більшості випадків це малоймовірно. Незважаючи на це, може бути корисним перерахувати кодування на місці з формату повідомлення. Крім того, якщо можна визначити і формат, і техніку обфускації, можна розробити автоматизовані атаки грубої сили.

Гібридні токени можуть містити таку інформацію, як IP-адреса або ідентифікатор користувача разом із закодованою частиною, як-от owaspuser:192.168.100.1:a7656fafe94dae72b1e1487670148412.

Після аналізу одного токена сеансу слід дослідити репрезентативну вибірку. Простий аналіз токенів повинен негайно виявити будь-які очевидні закономірності. Наприклад, 32-бітний маркер може містити 16 біт статичних даних і 16 біт змінних даних. Це може вказувати на те, що перші 16 бітів представляють фіксований атрибут користувача – наприклад, ім'я користувача або IP-адресу. Якщо друга 16-бітна послідовність збільшується зі звичайною швидкістю, це може вказувати на послідовний або навіть часовий елемент для генерації маркера. Подивіться приклади.

Якщо виявлено статичні елементи для маркерів, слід зібрати додаткові зразки, змінюючи один потенційний вхідний елемент за раз. Наприклад, спроби входу через інший обліковий запис користувача або з іншої IP-адреси можуть призвести до розбіжності в раніше статичній частині маркера сеансу.

Під час тестування структури ідентифікатора одного та кількох сеансів слід звернути увагу на наступні області:

- Які частини ідентифікатора сеансу є статичними?
- Яка конфіденційна інформація в відкритому вигляді зберігається в ідентифікаторі сеансу? наприклад імена користувачів/UID, IP-адреси
- Яка конфіденційна інформація, що легко розшифровується, зберігається?
- Яку інформацію можна вивести зі структури ідентифікатора сеансу?
- Які частини ідентифікатора сеансу є статичними для тих самих умов входу?
- Які очевидні шаблони присутні в ідентифікаторі сеансу в цілому чи окремих частинах?
- Передбачуваність і випадковість ідентифікатора сеансу
- Необхідно провести аналіз змінних областей (якщо такі є) ідентифікатора сеансу, щоб встановити існування будь-яких розпізнаваних або передбачуваних шаблонів. Ці аналізи можна виконувати вручну та за допомогою спеціально розроблених статистичних або криптоаналітичних інструментів або інструментів OTS для визначення будь-яких закономірностей у вмісті ідентифікатора сеансу. Перевірки вручну мають включати порівняння ідентифікаторів сеансу, виданих для тих самих умов входу, наприклад, однакового імені користувача, пароля та IP-адреси.

Час є важливим фактором, який також потрібно контролювати. Велика кількість одночасних підключень повинна бути зроблена, щоб зібрати зразки в одному часовому вікні та зберегти цю змінну постійною. Навіть квантування 50 мс або менше може бути занадто грубим, і вибірка, взята таким чином, може виявити часові компоненти, які інакше були б пропущені.

Змінні елементи слід аналізувати з часом, щоб визначити, чи є вони додатковими за своєю природою. Там, де вони є наростаючими, слід досліджувати закономірності, пов’язані з абсолютним або минулим часом. Багато систем використовують час як зерно для своїх псевдовипадкових елементів. Якщо закономірності виглядають випадковими, слід розглядати односторонні хеші часу або інші варіації середовища. Як правило, результатом криптографічного хешу є десяткове або шістнадцяткове число, тому його слід ідентифікувати.

Під час аналізу послідовностей ідентифікаторів сеансів, шаблонів або циклів статичні елементи та клієнтські залежності слід розглядати як можливі елементи, що вносять внесок у структуру та функції програми.

Чи є ідентифікатори сеансу випадковими за своєю природою? Чи можна відтворити отримані значення?
Чи ті самі умови введення дають той самий ідентифікатор під час наступного запуску?
Чи ідентифікатори сеансу стійкі до статистичного чи криптоаналізу?
Які елементи ідентифікаторів сеансу пов’язані з часом?
Які частини ідентифікаторів сеансу передбачувані?
Чи можна вивести наступний ідентифікатор, маючи повне знання алгоритму генерації та попередні ідентифікатори?
Зворотне проектування файлів cookie
Тепер, коли тестувальник перерахував файли cookie та має загальне уявлення про їх використання, настав час глибше розглянути файли cookie, які здаються цікавими. Які файли cookie цікавлять тестувальника? Файл cookie, щоб забезпечити безпечний метод керування сеансом, повинен поєднувати кілька характеристик, кожна з яких спрямована на захист файлу cookie від різного класу атак.

Ці характеристики підсумовані нижче:

Непередбачуваність: файл cookie повинен містити певну кількість даних, які важко вгадати. Чим важче підробити дійсний файл cookie, тим важче зламати сеанс законного користувача. Якщо зловмисник зможе вгадати файл cookie, який використовується в активному сеансі законного користувача, він зможе повністю видати себе за цього користувача (викрадення сеансу). Щоб зробити файл cookie непередбачуваним, можна використовувати випадкові значення або криптографію.
Стійкість до втручання: файл cookie має протистояти зловмисним спробам модифікації. Якщо тестувальник отримує файл cookie на кшталт IsAdmin=No, його легко змінити, щоб отримати права адміністратора, якщо тільки програма не виконує подвійну перевірку (наприклад, додаючи до файлу cookie зашифрований хеш його значення)
Термін дії: критичний файл cookie має бути дійсним лише протягом відповідного періоду часу, після чого його потрібно видалити з диска чи пам’яті, щоб уникнути ризику повторного відтворення. Це не стосується файлів cookie, які зберігають некритичні дані, які потрібно запам’ятовувати протягом сеансів (наприклад, зовнішній вигляд сайту).
Прапор безпеки: файл cookie, значення якого є критичним для цілісності сеансу, повинен мати цей прапорець, щоб дозволити його передачу лише в зашифрованому каналі для запобігання прослуховування.
Підхід тут полягає в тому, щоб зібрати достатню кількість екземплярів файлів cookie та почати пошук шаблонів у їхньому значенні. Точне значення «достатнього» може варіюватися від кількох зразків, якщо метод генерації cookie дуже легко зламати, до кількох тисяч, якщо тестувальнику потрібно продовжити певний математичний аналіз (наприклад, хі-квадрати, атрактори. Див. пізніше для додаткової інформації).

Важливо звернути особливу увагу на робочий процес програми, оскільки стан сеансу може сильно вплинути на зібрані файли cookie. Файл cookie, зібраний до автентифікації, може сильно відрізнятися від файлу cookie, отриманого після автентифікації.

Ще один аспект, який слід враховувати, це час. Завжди записуйте точний час отримання файлу cookie, якщо існує ймовірність того, що час відіграє роль у значенні файлу cookie (сервер може використовувати мітку часу як частину значення файлу cookie). Записаний час може бути місцевим часом або міткою часу сервера, включеною у відповідь HTTP (або обома).

Аналізуючи зібрані значення, тестувальник повинен спробувати з’ясувати всі змінні, які могли вплинути на значення файлу cookie, і спробувати змінити їх по черзі. Передача на сервер модифікованих версій того самого файлу cookie може бути дуже корисною для розуміння того, як програма зчитує та обробляє файли cookie.

Приклади перевірок, які необхідно виконати на цьому етапі, включають:

Який набір символів використовується в файлі cookie? Чи має файл cookie числове значення? буквено-цифровий? шістнадцятковий? Що станеться, якщо тестер вставить у файл cookie символи, які не належать до очікуваного набору символів?
Чи файл cookie складається з різних частин, що містять різну інформацію? Як розділені різні частини? З якими роздільниками? Деякі частини файлу cookie можуть мати більшу дисперсію, інші можуть бути постійними, інші можуть приймати лише обмежений набір значень. Першим і фундаментальним кроком є розбиття файлу cookie на основні компоненти.
Нижче наведено приклад легкого для виявлення структурованого файлу cookie:

ID=5a0acfc7ffeb919:CR=1:TM=1120514521:LM=1120514521:S=j3am5KzC4v01ba3q
У цьому прикладі показано 5 різних полів, що містять різні типи даних:

ID – шістнадцятковий
CR – мале ціле число
TM і LM – велике ціле число. (І, що цікаво, вони мають однакове значення. Варто подивитися, що станеться, змінивши один із них)
S – буквено-цифровий

Навіть якщо не використовуються роздільники, наявність достатньої кількості зразків може допомогти зрозуміти структуру.

### Атаки грубою силою
Атаки грубою силою неминуче ведуть до питань, що стосуються передбачуваності та випадковості. Розбіжність між ідентифікаторами сеансу слід враховувати разом із тривалістю сеансу програми та тайм-аутами. Якщо варіація ідентифікаторів сеансу є відносно невеликою, а термін дії ідентифікатора сеансу тривалий, ймовірність успішної атаки методом грубої сили набагато вища.

Довгий ідентифікатор сеансу (точніше ідентифікатор із великою дисперсією) і коротший період дії значно ускладнять успіх атаки грубою силою.

Скільки часу триватиме атака грубою силою на всі можливі ідентифікатори сеансу?
Чи достатньо великий простір ідентифікатора сеансу, щоб запобігти грубому форсування? Наприклад, чи достатньо довжини ключа порівняно з дійсним терміном служби?
Чи зменшують затримки між спробами підключення з різними ідентифікаторами сеансу ризик цієї атаки?
Тестування та приклад Gray-Box
Якщо тестувальник має доступ до реалізації схеми керування сеансом, він може перевірити наступне:

### Маркер випадкового сеансу

Ідентифікатор сеансу або файл cookie, виданий клієнту, не повинен бути легко передбачуваним (не використовуйте лінійні алгоритми на основі передбачуваних змінних, таких як IP-адреса клієнта). Заохочується використання криптографічних алгоритмів із довжиною ключа 256 біт (наприклад, AES).

Довжина жетона

Ідентифікатор сеансу матиме принаймні 50 символів.

Тайм-аут сеансу

Маркер сеансу повинен мати визначений тайм-аут (це залежить від критичності керованих даних програми)

### Конфігурація файлів cookie:

непостійний: тільки оперативна пам'ять
безпечний (встановлюється лише на каналі HTTPS): Set-Cookie: cookie=data; шлях=/; домен=.aaa.it; безпечний
HTTPOnly (не читається сценарієм): Set-Cookie: cookie=data; шлях=/; домен=.aaa.it; HttpOnly
